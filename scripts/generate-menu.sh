#!/bin/bash
# =============================================================================
# Netboot Server - Generate iPXE Boot Menu
# =============================================================================
# Scans the images/ directory and generates menu.ipxe dynamically.
# Each image folder should contain a config.json with metadata.
# =============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
IMAGES_DIR="$PROJECT_DIR/images"
MENU_FILE="$PROJECT_DIR/config/ipxe/menu.ipxe"
LOGS_DIR="$PROJECT_DIR/logs"

# ---------------------------------------------------------------------------
# Logging setup — logs to file and console
# ---------------------------------------------------------------------------
mkdir -p "$LOGS_DIR"
SCRIPT_NAME="$(basename "$0" .sh)"
LOG_TIMESTAMP="$(date '+%Y-%m-%d_%H-%M-%S')"
LOG_FILE="$LOGS_DIR/${SCRIPT_NAME}_${LOG_TIMESTAMP}.log"

# Start logging (tee to both console and file)
exec > >(tee -a "$LOG_FILE") 2>&1

echo "=========================================="
echo " Log started: $(date '+%Y-%m-%d %H:%M:%S')"
echo " Log file: $LOG_FILE"
echo "=========================================="
echo ""

# Source .env for server IP
if [ -f "$PROJECT_DIR/.env" ]; then
    source "$PROJECT_DIR/.env"
fi

SERVER_IP="${TFTP_SERVER_IP:-192.168.1.100}"
HTTP_PORT_VAL="${HTTP_PORT:-8080}"
MENU_TITLE_VAL="${MENU_TITLE:-Netboot Server}"

echo "Generating iPXE boot menu..."
echo "  Images dir: $IMAGES_DIR"
echo "  Output:     $MENU_FILE"

# Start building the menu
cat > "$MENU_FILE" << HEADER
#!ipxe
#
# Netboot Server - Boot Menu
#
# AUTO-GENERATED by scripts/generate-menu.sh
# Do not edit manually — changes will be overwritten.
#
# Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
#

set server-url http://${SERVER_IP}:${HTTP_PORT_VAL}

:menu
menu ${MENU_TITLE_VAL} - Select an image to install
HEADER

# Collect Linux, Windows, and VMware entries separately
LINUX_ITEMS=""
LINUX_ENTRIES=""
WINDOWS_ITEMS=""
WINDOWS_ENTRIES=""
VMWARE_ITEMS=""
VMWARE_ENTRIES=""

# Scan for image directories with config.json
for config_file in "$IMAGES_DIR"/*/config.json; do
    [ -f "$config_file" ] || continue

    dir="$(dirname "$config_file")"
    folder="$(basename "$dir")"

    # Read config.json fields
    name=$(python3 -c "import json; d=json.load(open('$config_file')); print(d.get('name','$folder'))" 2>/dev/null || echo "$folder")
    os_type=$(python3 -c "import json; d=json.load(open('$config_file')); print(d.get('type','linux'))" 2>/dev/null || echo "linux")
    distro=$(python3 -c "import json; d=json.load(open('$config_file')); print(d.get('distro',''))" 2>/dev/null || echo "")
    boot_type=$(python3 -c "import json; d=json.load(open('$config_file')); print(d.get('boot_type','kernel'))" 2>/dev/null || echo "kernel")
    kernel=$(python3 -c "import json; d=json.load(open('$config_file')); print(d.get('kernel',''))" 2>/dev/null || echo "")
    initrd_file=$(python3 -c "import json; d=json.load(open('$config_file')); print(d.get('initrd',''))" 2>/dev/null || echo "")
    boot_args=$(python3 -c "import json; d=json.load(open('$config_file')); print(d.get('boot_args',''))" 2>/dev/null || echo "")
    iso_file=$(python3 -c "import json; d=json.load(open('$config_file')); print(d.get('iso',''))" 2>/dev/null || echo "")

    if [ "$os_type" = "linux" ]; then
        LINUX_ITEMS="${LINUX_ITEMS}item ${folder}       ${name}\n"

        # Build the boot entry
        boot_entry=":${folder}
set base-url \${server-url}/images/${folder}"

        # Add tip for Ubuntu about DHCP
        if [ "$distro" = "ubuntu" ]; then
            boot_entry="${boot_entry}
echo
echo =====================================================
echo  TIP: Ubuntu installer starts with network DISABLED
echo  You must manually enable DHCP on your interface:
echo  Network connections > ens* > Edit IPv4 > Automatic
echo =====================================================
echo
echo Booting in 10 seconds...
sleep 10"
        fi

        # Debian: Special handling for local HTTP mirror
        if [ "$distro" = "debian" ]; then
            boot_entry="${boot_entry}
echo
echo =====================================================
echo  TIP: If DHCP auto-config fails, select your network
echo  interface and choose Configure network manually or
echo  retry DHCP from the network configuration menu.
echo =====================================================
echo
echo Booting Debian installer in 10 seconds...
sleep 10
kernel \${base-url}/${kernel} initrd=${initrd_file} netcfg/choose_interface=auto mirror/country=manual mirror/protocol=http mirror/http/hostname=${SERVER_IP} mirror/http/directory=/images/${folder} mirror/http/proxy=
initrd \${base-url}/${initrd_file}
boot || goto menu"
            LINUX_ENTRIES="${LINUX_ENTRIES}
${boot_entry}
"
            continue
        fi

        # Check boot type: "nfs", "iso", or "kernel" (default)
        if [ "$boot_type" = "nfs" ]; then
            # NFS boot (for Proxmox, TrueNAS, etc.)
            # Kernel+initrd with NFS root parameters
            if [ "$distro" = "proxmox" ]; then
                boot_entry="${boot_entry}
echo
echo =====================================================
echo  Proxmox VE PXE Boot (ISO embedded in initrd)
echo =====================================================
echo
echo NOTE: This downloads a ~1.5GB initrd with embedded ISO
echo Requires: 4GB+ RAM on the target machine
echo
echo Starting download - please wait...
echo
kernel \${base-url}/${kernel} vga=791 video=vesafb:ywrap,mtrr:3 ramdisk_size=16777216 rw quiet splash=silent
initrd \${base-url}/boot/initrd-pxe.img
boot || goto menu"
            elif [ "$distro" = "truenas" ]; then
                boot_entry="${boot_entry}
echo
echo Booting TrueNAS Scale via HTTP fetch...
echo IP: \${net0/ip} GW: \${net0/gateway}
echo
echo NOTE: TrueNAS requires 16GB+ RAM for PXE install
echo The 1.6GB update file will be downloaded after boot
echo
kernel \${base-url}/${kernel} boot=live staticip=eth0:\${net0/ip}:\${net0/netmask}:\${net0/gateway}:\${net0/dns} updateurl=\${base-url}/TrueNAS-SCALE.update ethdevice=eth0 net.ifnames=0 biosdevname=0 fetch=\${base-url}/live/filesystem.squashfs console=tty0
initrd \${base-url}/${initrd_file}
initrd \${base-url}/netboot-init.img
boot || goto menu"
            fi
        elif [ "$boot_type" = "iso" ]; then
            # sanboot ISO boot (fallback)
            boot_entry="${boot_entry}
echo
echo Booting ISO via sanboot (UEFI)...
echo ISO: ${iso_file}
echo
echo If this fails, enable CSM/Legacy mode in BIOS settings.
echo
sanboot \${base-url}/${iso_file} || goto menu"
        else
            # Standard kernel+initrd boot
            boot_entry="${boot_entry}
kernel \${base-url}/${kernel} initrd=${initrd_file} ${boot_args}
initrd \${base-url}/${initrd_file}
boot || goto menu"
        fi

        LINUX_ENTRIES="${LINUX_ENTRIES}
${boot_entry}
"
    elif [ "$os_type" = "windows" ]; then
        WINDOWS_ITEMS="${WINDOWS_ITEMS}item ${folder}       ${name}\n"
        WINDOWS_ENTRIES="${WINDOWS_ENTRIES}
:${folder}
set base-url \${server-url}/images/${folder}
kernel \${server-url}/images/wimboot
initrd \${base-url}/boot/bcd        BCD
initrd \${base-url}/boot/boot.sdi   boot.sdi
initrd \${base-url}/sources/boot.wim boot.wim
boot || goto menu
"
    elif [ "$os_type" = "vmware" ]; then
        VMWARE_ITEMS="${VMWARE_ITEMS}item ${folder}       ${name}\n"

        # ESXi uses chainloading mboot.efi with boot.cfg
        bootloader=$(python3 -c "import json; d=json.load(open('$config_file')); print(d.get('bootloader','mboot.efi'))" 2>/dev/null || echo "mboot.efi")
        boot_cfg=$(python3 -c "import json; d=json.load(open('$config_file')); print(d.get('boot_cfg','boot.cfg'))" 2>/dev/null || echo "boot.cfg")

        VMWARE_ENTRIES="${VMWARE_ENTRIES}
:${folder}
set base-url \${server-url}/images/${folder}
echo
echo =====================================================
echo  VMware ESXi PXE Boot
echo =====================================================
echo
echo  IMPORTANT: ESXi requires BARE METAL hardware or
echo  compatible virtualization (VMware Workstation/ESXi).
echo
echo  ESXi does NOT work on: Hyper-V, VirtualBox
echo  (black screen after kernel load)
echo
echo =====================================================
echo
echo Booting in 10 seconds...
sleep 10
kernel \${base-url}/${bootloader} -c \${base-url}/${boot_cfg} prefix=\${base-url}
boot || goto menu
"
    fi

    echo "  Found: $folder ($os_type) - $name"
done

# Write menu items
{
    # Linux section
    if [ -n "$LINUX_ITEMS" ]; then
        echo "item --gap --           === Linux ==="
        echo -e "$LINUX_ITEMS"
    fi

    # Windows section
    if [ -n "$WINDOWS_ITEMS" ]; then
        echo "item --gap --           === Windows ==="
        echo -e "$WINDOWS_ITEMS"
    fi

    # VMware section
    if [ -n "$VMWARE_ITEMS" ]; then
        echo "item --gap --           === VMware ==="
        echo -e "$VMWARE_ITEMS"
    fi

    # No images found
    if [ -z "$LINUX_ITEMS" ] && [ -z "$WINDOWS_ITEMS" ] && [ -z "$VMWARE_ITEMS" ]; then
        echo "item --gap --           === No images found ==="
        echo "item --gap --           Add images to the images/ directory"
    fi

    # Tools section
    echo "item --gap --           === Tools ==="
    echo "item shell              Drop to iPXE shell"
    echo "item reboot             Reboot"
    echo "item exit               Exit to local boot"
    echo "choose selected || goto exit"
    echo "goto \${selected}"
    echo ""

    # Linux boot entries
    if [ -n "$LINUX_ENTRIES" ]; then
        echo "# ---------------------------------------------------------------------------"
        echo "# Linux entries"
        echo "# ---------------------------------------------------------------------------"
        echo "$LINUX_ENTRIES"
    fi

    # Windows boot entries
    if [ -n "$WINDOWS_ENTRIES" ]; then
        echo "# ---------------------------------------------------------------------------"
        echo "# Windows entries"
        echo "# ---------------------------------------------------------------------------"
        echo "$WINDOWS_ENTRIES"
    fi

    # VMware boot entries
    if [ -n "$VMWARE_ENTRIES" ]; then
        echo "# ---------------------------------------------------------------------------"
        echo "# VMware entries"
        echo "# ---------------------------------------------------------------------------"
        echo "$VMWARE_ENTRIES"
    fi

    # Utility entries
    cat << 'UTILS'
# ---------------------------------------------------------------------------
# Utilities
# ---------------------------------------------------------------------------

:shell
echo Type "exit" to return to the menu.
shell
goto menu

:reboot
reboot

:exit
exit
UTILS
} >> "$MENU_FILE"

echo ""
echo "Menu generated: $MENU_FILE"
echo "Done."
